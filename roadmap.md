# Ошибки в программе

## Падение в многопоточности

Проблема:

Если рабочий поток один, то не падает.
Если рабочих потоков больше, то падает.

На каждый запрос свой отдельный ClientRequest.
Для каждой асинхронной операции создавать новый ClientRequest, старый ClientRequest будет клонирован.

Что сделал:

* [x] Убрать WSAGetOverlappedResult и использовать то, что возвращает GetQueueCompletionStatus

Возможно обнаружил причину.
Пришло 0 байт — идёт сразу же удаление ClientContext.
При этом другой поток возможно ещё обрабатывает запрос.
Одновременный доступ к ClientContext из разных потоков.
Попробовать:
* [ ] наследовать не от OVERLAPPED
* [ ] использовать CompletionKey
* [ ] при ошибке или получении 0 байт закрывать сокет. Когда закрывать?

Если одновременно выполняются и BeginRead и Release, значит нужно Release убрать и поставить в другом месте.


Для одного потока:
* Убрать вход в критическую секцию в HttpReader для однопоточности
* Убрать защиту счётчика ссылок во всех объектах для однопоточности
* Вместо критической секции вызывать Interlocked‐функции

Проверить разницу в поведении:
* Connection: Close от клиента
* Connection: Keep-Alive от клиента
* Connection: Close от сервера принудительно в многопоточности
* Connection: Close от сервера принудительно в многопоточности и без Release контекста клиента



Проверить поведение:
много рабочих потоков и один запрос за раз
много рабочих потоков и много запросов за раз
один рабочий поток и один запрос за раз
один рабочий поток и много запросов за раз

Нездоровая конкуренция между рабочими потоками?

Загуглить: Как отлаживать проблемы с многопоточностью.


* Сделать методы возвращающие слабую ссылку на интерфейс (без увеличения счётчика ссылок)


## Обработчики запросов

Каждый HTTP‐метод обрабатывает отдельный класс. Например, метод GET обрабатывае IHttpGetProcessor.

Эти обработчики регистрируются заранее в сервере, в файлах конфигурации или ещё где.

При поступлении запроса сервер проверяет метод и вызывает функцию соответствующего обработчика.

Нужно ли поддерживать разных обработчиков для разных ресурсов? Например, разные обработчики для `GET /foo` и `GET /bar`? Наверное, надо. А для версии протокола? Или абстрагировать версию, чтобы обработчики действовали независимо.


## Утечка памяти

Исправлен неверный подсчёт количества выделений памяти, из‐за чего показывалось неверное сообщение об утечке.


## Собирать лог

Как собирать лог, чтобы он не пересекался с другим потоком? Сервер создаёт объекты, которые пишут информацию в лог. Варианты:

* отдельный объект логирования для каждого потока;
* вывод на консоль один раз: когда отправлен ответ.


## Рефракторинг

Класс WebServer. Что там за объект pINetworkStream и почему его необходимо каждый раз закрывать после соединения с пользователем.

Файл Read.Me изменить так. Оставить только общую информацию, перевести на «международный язык», остальное отправить в другой файл или на вики по вебсерверу.

Настройки сайта: разделить путь wwwroot на две части. 1. Собственно wwwroot с файлами сайта. 2. Путь к конфигурации сайта. Это разрешит отправлять любой файл из wwwroot, даже если у него нет зарегистрированного MIME.